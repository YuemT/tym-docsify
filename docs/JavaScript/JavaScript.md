> JavaScript是运行在浏览器端一门脚本语言，JavaScript的标准称为ECMAScript.  

这一阶段学习JS，主要分成三个部分  
* ES标准
* DOM
* BOM	

#### <div id='a'>一.简介</div>
##### JS代码的编写位置

1. 编写在标签内部的指定属性中  
    _将JS代码编写到HTML的属性中，我们称为结构与行为耦合，不方便维护_

        <button onclick="....">按钮</button>
        <a href="javascript:...;">超链接</a>
    
2. 可以将JS代码编写到超链接的href属性中，这样当点击超链接时，将不会跳转页面而是执行这些js代码
     
        <a href="javascript:;">超链接</a>
      
3. 编写在script标签中

        <script type="text/javascript">
            ....
        </script>
    
4. 编写到外部的js文件中,然后通过script标签进行引入
    
        <script type="text/javascript" src="script.js"></script>

##### 基本语法

单行注释     
    
    //注释内容
多行注释

    /*
        注释内容
    */
_通过注释可以对程序进行解释描述，一定要养成良好的编写注释习惯，通过注释也可以对程序进行一个简单的调试_  
在JS中严格区分大小写  	
在JS中会忽略多个空格和换行，我们可以通过空格和换行对代码进行格式化  
JS的每条语句都要以分号结尾，如果不写分号浏览器会自动添加，这一阶段强制要求必须写  

##### 字面量
字面量简单理解就是一些固定的值，字面量都是不会改变的，在js中可以直接使用字面量，比如：1 2 3 4 "a" "b" "c"  
字面量在实际使用中并不是很方便，一般情况下不会直接使用字面量

##### 变量
变量可以用来保存字面量，变量可以保存不同的字面量，并且可以任意修改。  
我们在开发中，一般不会直接使用字面量，而是使用变量来保存一个字面量，使用变量也可以对字面量进行描述。  
变量的使用
1. 声明变量
    * 使用var关键字来声明一个变量
    
            var a; var b; var c , d , e;
    _如果使用没有声明的变量，浏览器会报错_
    
2. 为变量赋值  
    * 使用 = 为一个变量赋值 
            
            a = 1 ; b = 2 ; c = 3;
    _如果声明了一个变量但是没有赋值，则此时变量的值是 undefined_
3. 声明和赋值同时进行
    
        var a = 1;
        var b = 2;
        var c = 3 , d = 4 , e = 5;
             
##### 标识符
在JS中所有可以自主命名的内容都可以认为是一个标识符,比如：变量名 函数名 属性名。。。  
标识符在JS底层都是使用Unicode编码进行保存的，所以理论上讲，只要是Unicode编码中有的都可以作为标识符.但是还是要遵循规范  
标识符需要遵循如下的规范:
1. 标识符中可以包含字母、数字 、_ 、$，但是不能以数字开头
2. 标识符不能是JS中的关键字和保留字
3. 标识符需要采用驼峰命名法
    - 首字母小写，每个单词开头字母大写
    - 例子：helloWorld xxxYyyZzz  
4. 不能把关键字、保留字、true、false和null用作标识符  
_在代码中使用关键字作为标识符在大多数浏览器中都会倒是“Identifier Expected”（缺少标识符）错误。而使用保留字可能不会导致同样的错误，这要视具体的浏览器而定。一般来说，最好不要使用关键字和保留字作为标识符，以便与ECMAScript未来的版本保持兼容。_

##### 关键字
js中的关键字可用于表示控制语句的开始或结束，或者用于执行特定操作等。按照规则，关键字也是语言保留的，不能用作标识符。  
以下就是ECMAScription的全部关键字：

    break、else、new、var、 case、  finally 、 return、 void 、 catch  、for  、switch 、 while 、   
    continue、  function  、this 、 with 、  default 、 if 、 throw 、 delete 、 in 、  try 、do 、  
     instranceof、  typeof

##### 保留字
ECMA还描述了另外一组不能用作标识符的保留字。尽管保留字在这门语言中还没有任何特定的用途，但它们有可能将来被用作关键字。   
下面是ECMA第3版定义的全部保留字：
        
     abstract 、 enum   、int 、 short 、 boolean  、export  、interface、  static、  byte  、extends 、
      long 、 super 、 char 、 final  、native  、synchronized 、 class  、float 、 package  、throws 、
      const  、goto  、private 、transient 、 debugger、 implements 、protected 、 volatile 、 double、
     import  、public

##### {   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }

在JS中可以使用{     }来将多个语句包含起来  
在同一个{   }中的语句属于一组语句，一个{   }我们就称为是一个代码块  
一个代码块中的语句要么都执行，要么都不执行  
在JS中{    }只有分组的作用，没有其他的任何作用  
代码块中的内容，对于外部来说是可见的  

#### <div id='b'>二.基本数据类型（5种）</div>
##### String（字符串）
在JS中字符串需要使用引号引起来，单引号或双引号
- 同类型的引号不能嵌套
- 使用typeof检查一个String类型的值时，会返回 string
- 使用 \ 来作为转义字符  

        \"  ---> "
        \' ---> '
        \\ ---> \
        \n ---> 换行
        \t ---> 制表符
        \uxxxx ---> Unicode编码
            
##### Number（数值）
在JS中所有的数字都是Number类型（包括整数和浮点数）  
使用typeof检查一个Number类型的值时会返回number
  
1. 特殊的数字：
    
    * Infinity 正无穷，当我们使用的数字超过了JS的范围时，会返回Infinity
    * NaN（Not a Number）非法数字  
    _注意使用typeof检查Infinity和NaN时都会返回number_
    
2. 其他的进制的数字（并不是所有的浏览器都支持）
    * 二进制 0b开头（兼容性不好）  八进制 0开头    十六进制 0x开头

3. 在JS中可以表示的最大值 
    * Number.MAX_VALUE   1.7976931348623157e+308
      
4. 在JS中可以表示的最小值	
    * Number.MIN_VALUE     5e-324
    
_在JS中，大部分的整数运算都可以确保精确.但是如果进行浮点数运算，可能会出现不可预期的结果.也就是结果是不够精确的，注意不要在JS做精度要求高的运算_

##### Boolean（布尔值）
布尔值用来在程序中做逻辑判断的
* true 表示真
* false 表示假 
 
_使用typeof检查一个布尔类型的值时，会返回boolean_

##### Null（空值）
Null专门用来表示为空的对象  
_使用typeof检查Null时，会返回object_

##### Undefined（未定义）
Undefined表示声明但没有赋值的变量值是undefined  
_使用typeof检查时，会返回undefined_

#### <div id='c'>三.数据类型的转换</div>
类型转换指将其他的数据类型转换为String Number Boolean
转换方式分成两种：
* 强制类型转换 
* 隐式的类型转换

##### String
__String强制转换__
* toString()--调用被转换数据类型的toString()方法 
    * 对于Number类型调用toString()时，可以在方法中传递一个进制来作为参数.这样可以将数字转换为指定进制的字符串
         
                    var a = 123;
                    a = a.toString();
         _注意：在null和undefined中没有toString()方法,所以如果对这两个值调用toString()会报错_
     
* String()--调用String()函数来将其他数据类型转换为字符串，需要将被转换的数据作为函数的参数传递
    * 注意：String()函数对于有toString()方法值，还是调用的toString()方法.   
                var a = 123;   a = String(a);
       
   _对于null，它会将其直接转换为"null",对于undefined，它会直接将其转换为"undefined"_
   
__String隐式转换__
* 为一个任意的数据类型加上一个空串的形式来将其转换为字符串

            var a = 123;
            a = a + "";
        
    _原理和String()函数一样_
            
##### Number
__Number强制转换__
* Number()--调用Number()函数来将其他的数据类型转换Number
    
            var a = "123";      a = Number(a);
    - 转换的情况
    
            - 字符串
                1.如果是合法的数字，则直接转换为对应的数字
                2.如果不是合法的数字，则直接转换NaN
                3.空串和纯空格的字符串会转换为0
            
            - 布尔值
                1.true转换为1
                2.false转换为0
            
            - Null
                null转换为0
                - Undefined
                undefined转换为NaN
* parseInt()--将一个字符串转换为一个整数
    
            var a = "100px";
            a = parseInt(a);
            
    _parseInt()解析一个字符串时，会自左向右解析,会将所有的合法的整数部分提取出来，并转换为数字.如果对于非字符串调用parseInt()它会先将其转换为字符串，然后再解析_

* parseFloat()	
    - 它和parseInt()用法类似，不同是他可以解析出字符串中有效的小数
    
__Number隐式转换__
* 可以通过为一个任意类型的值，添加一个一元的+来将其转换为Number
            
        var a = "123"
        a = +a;
        
    _原理和Number()函数一样_
        
##### Boolean
__Boolean强制转换__
* Boolean()
    - 调用Boolean()函数来将其他数据类型转换为布尔值
    
            var a = "false";    a = Boolean(a);
    - 不同的情况：
        - String      - 除了空串，其余都是true
        - Number   - 除了0和NaN，其余都是true
        - Null和Undefined      - 都是false
        - 对象，一般情况下都是true	

__Boolean隐式转换__
- 可以通过为一个任意数据类型取两次反，来将其转换为布尔值
    
        var a = 123;    a = !!a;
    _原理和Boolean()函数一样_	
  
#### <div id='d'>四.引用数据类型</div>
##### Object（对象）  
对象是一种复合数据类型，通过对象可以表示各种复杂的数据
对象就相当于一个容器，在对象中可以保存多个不同类型的属性  
_使用typeof检查一个对象时会返回object_

##### 对象的分类
1. 内建对象
    * 由ES标准内部定义的对象，这些对象在任何对象ES标准的实现中都可以使用
        
            String Number Boolean Math Array Object Function ...
        
2. 宿主对象
    * 由JS引擎提供的对象（目前主要指由浏览器提供的对象）
            
            BOM 和 DOM
        
3. 自定义对象
    * 由我们自己定义的对象
    
##### 对象的创建
1. 使用构造函数（constructor）
           
           var obj = new Object();
2. 使用对象字面量
        
            var obj = {};
    * 可以在创建对象的同时，向对象中添加属性
    * 属性名和属性值之间使用:连接，
    * 属性之间使用,隔开
    * 如果属性是最后一个属性，就千万不要再写,
    * 如果属性名是一个特殊的名字，可以使用引号引起来

##### 属性名
* 对象的属性名，没有任何限制，不用必须遵循标识符的规范，
使用任何名字都可以，但是注意使用特殊名字时，需要使用 [    ] 这种方式来操作
* 通过.操作属性 和 [  ]操作属性我们都会用到，[  ]相比.更加灵活，因为[]可以传变量
- 但是虽然不强制要求我们遵循标识符的规范，但是一般在开发中还是会遵循该规范

##### 属性值
* 对象中的属性的属性值可以是任意的数据类型
也可以是一个对象，甚至也可以是一个函数
* 当一个对象的属性是一个函数时，我们称函数是对象的方法，
调用函数时，我们称调用了对象的方法
* 注意：方法和对象本质上没有区别，仅仅是名称的区别
obj.test(  );

##### 对象的属性的操作
1. 添加(修改)属性
    - 语法：
            对象.属性名 = 属性值
            对象["属性名"] = 属性值
    
            obj.name = "";
            obj["name"] = "";
                    
    - 在创建对象时，以字面量的形式，向对象中添加属性
    
            var obj = {
                        name:"",
                        age:18,
                        gender:""
                    };
2. 读取属性
    - 语法：
          对象.属性名     对象["属性名"]
          obj.name      obj["age"]
    - 注意：如果读取一个对象中没有的属性时，它不会报错而是返回undefined
3. 删除属性
    - 语法：delete 对象.属性名
        
            delete obj.name
4. in运算符
    - 使用in运算符，可以用来检查一个对象中是否含有指定的属性
    - 语法："属性名" in 对象
            
             console.log("hello" in obj2);
    - 使用in运算符，无论属性是在原型中还是在自身中，都会返回true
5. for...in语句
    - 可以用来对对象中的属性进行枚举
    
             for(var 变量 in 对象){
                ...
            }
    - for in 的循环体会执行多次,
    对象中有几个属性就会执行几次,
    每次执行都会将对象中的一个属性名赋值给变量.
6. hasOwnProperty()

    - 可以用来检查一个属性是否是对象自身的属性
    - 语法：对象.hasOwnProperty("属性名");

##### 垃圾回收（GC）
* 一个对象如果没有任何变量对其进行引用，则此时我们将无法再使用该对象，但是这些对象还会存在于内存中
* 如果这种对象过多，会影响程序的运行的性能，所以浏览器中有自动的垃圾回收机制，可以对这些对象进行回收
- 一系列垃圾回收的操作都是由浏览器自动进行，我们不需要操作，我们只需要将不再使用的对象设置为null即可

#### <div id='e'>五.基本数据类型和引用数据类型的区别</div>
- 一个变量在保存基本数据类型时，它是直接保存数据的值，基本数据类型的值都是保存到栈内存中的，而且值与值之间都是独立的，修改一个变量，不会影响其他的变量。
- 一个变量在保存引用数据类型时，对象是存储在堆内存中的，在变量中保存的是对象的内存地址（引用），
   操作对象时，我们是通过引用来操作对象
   如果两个变量保存的是同一个对象的引用，则一个变量修改对象时，另一个也会受到影响。
- 基本数据类型做相等比较时，比较的是两个数据的值
而引用数据类型比较的是内存地址，如果两个对象长的一模一样，但是内存地址不同也会返回false

#### <div id='f'>六.函数（function）</div>
函数也是一个对象，对象能做的事他都可以做。
普通对象里边只可以存储属性，在函数中可以保存一些可以执行的代码，并且在需要时对这些代码进行调用  
_使用typeof检查一个函数对象时会返回function_

##### 函数的创建
1. 构造函数
    * 创建一个函数对象，可以将代码以字符串的形式传递到构造函数中，我们一般不会使用这种方式来创建函数
    
            var fun = new Function("alert('我是函数中的代码');");
2. 函数声明
    * 语法：function 函数名([形参1,形参2,.....形参N]){
                         语句...
                      }	
                      
            function sum(a , b){
                return a + b;
            }
3. 函数表达式
    * 语法：var 函数名 = function([形参1,形参2,.....形参N]){
            语句....
                    };
        
            var sum = function(a,b){
                    return a + b;
                    };
                    
##### 函数的调用
函数调用就是将函数中封装的代码执行,如果函数对象+()就相当于调用函数，而如果函数不+(),就相当于直接使用函数对象

语法：函数对象()
        
        fun(123,456)
        
函数在调用时，都会有两个隐含参数被传递进来
* this（上下文对象）
    * this是函数中的隐含参数，函数每次调用时都会有一个this被传递进来
    - this代表的是函数执行的上下文对象
    * 根据函数的调用方式的不同，this的值也不同	
        1. 以函数形式调用时，this是window
        2. 以方法的形式调用时，this是调用方法的对象
        3. 以构造函数的形式调用时，this是新创建的那个对象
        4. 在全局作用域中this是window
        5. 以call()或apply()去调用函数时，它们的第一个参数就是this
* arguments（实参）
    * 函数调用时，除了this，还有一个隐含的参数就是arguments
    * arguments是一个类数组的对象
        - 在函数调用时，我们所传递的实参都会保存到arguments对象中，
        - 即使不定义形参也可以通过arguments来使用实参
             - arguments.length - 用来获取实参的数量
             - arguments[索引] - 可以获取指定的实参
        - 在arguments中还有一个属性callee，这个属性指向的是当前调用的函数对象

##### 参数
形参（形式参数）
* 在定义函数时，可以在函数指定一个或多个形参
* 在函数中定义形参就相当于在函数中声明了变量但是并不赋值
    
实参(实际参数)
* 在调用函数时，可以在函数中传递实参，实参将会赋值给对应的形参
  - JS引擎在调用函数时，不会检查实参的类型和数量
  - 可以传递任意类型的实参
  - 也可以传递任意数量的实参
  - 如果实参和形参一样多，则对应的实参会赋值给对应的形参
  - 如果实参大于形参的数量，则多余实参的不会被使用
  - 如果实参小于形参的数量，则没有对应实参的形参的值将会是undefined

##### 返回值
返回值就相当于函数的执行结果，在函数执行完毕以后可以通过一个变量来接收返回值
- 通过return 来指定函数的返回值
- 语法：return 值;
- return后的值将会作为函数的执行结果返回
如果不写return，或者return 后不跟任何值，则函数会默认返回undefined
 return后的所有的代码都不会执行，一旦return执行，则函数立即结束（return可以用来退出函数）
- 任何值都可以作为函数的返回值	

##### 匿名函数（立即执行函数）
这种格式的函数，称为立即执行函数，定义完成后会立即被调用，而且只会执行一次

    (function( ){  })( alert("我是一个匿名函数"); )；
            
##### 构造函数constructor
使用new关键字调用的函数称为构造函数，构造函数是专门用来创建对象的函数.它本质上就是一个普通的函数，如果一个函数直接调用，那么它就是一个普通的函数，如果使用new关键字来调用，那么他就是一个构造函数  

构造函数的执行流程：
1. 创建一个新的对象
2. 将新的对象设置函数的this
3. 执行函数中的代码
4. 将新建的对象作为返回值返回
            function Person(name , age , address){
                //在构造函数中，this就是新创建的对象
                            this.name = name;
                            this.age = age;
                            this.address = address;
                            this.sayName = function(){
                                console.log(this.name);
                            };
                        }
            var per = new Person("孙悟空",18,"花果山");
            console.log(per);
            —————输出结果Person对象per
    
_构造函数中一般不需要写return来指定返回值.没有意义，除非有特殊用途_
  
##### 原型（prototype）
我们所创建的每一个函数，浏览器都会默认为他们添加一个属性，这个属性叫做prototype,该属性对应的值是一个原型对象
- 如果函数作为普通函数调用则prototype没有任何作用
- 如果函数作为构造函数调用时，则使用该函数所创建的对象中,都会有一个隐含的属性__proto__指向该函数的prototype对象
- 默认情况下，所有的通过同一个构造函数所创建的对象，都会拥有相同的原型对象。
- 当我们调用对象中的一个属性或一个方法时，它会现在对象自身中寻找，如果有则直接使用，
    如果没有则去对象的原型中寻找（__proto__），如果找到了则使用，
    如果没找到则去对象的原型的原型中寻找（__proto__.__proto__），以此类推
   直到找到Object的原型，Object的原型的原型是null，
   它的原型没有原型，如果依然没有找到，则返回undefined
* 当我们将一个方法定义在了构造函数内部
  这样每创建一个对象，就要创建一个新的方法，
  所以通过这个构造函数所创建的对象，他们的这个方法都是不同的对象，
  有几个对象就会有几个方法，而且这些方法它们的功能都是一摸一样的
  所以这些对象会大量的占用内存空间，而且没有什么用。。。
  
  可以将函数定义在全局作用域中，然后将其设置为对象的方法
  这样无论构造函数执行多少次，我们也只有一个sayName
  但是将函数定义在了全局作用域中，会污染全局命名空间，
  别的函数或变量将不能以此命名，如果以此命名将会导致方法被覆盖
  
  可以将对象中共有的属性和方法，统一保存到原型中，这样只需添加一次即可使所有的对象共有这些属性和方法，并且不会污染命名空间
  
        Person.prototype.sayName = function(){
            console.log("我叫:"+this.name+", 家住:"+this.address);
        };
        
##### call()和apply()
- 这两个是函数对象的方法，需要通过函数对象调用
  当调用call()和apply()会直接执行函数
- 通过这两个方法可以对当前函数进行调用，并且指定当前函数的this，
       它们的第一个参数将会成为函数的this。
       通过call调用一个函数时，可以将实参作为第二个参数来传递
       apply()不能将参数一个一个的列出来，而是需要封装到一个数组中传递 
- 不同点：  
    * call(    )的实参需要一个一个的传递
    * apply(    )的实参需要保存到一个数组中来传递

#### <div id='g'>七.数组（Array）</div>
数组也是一个对象，在数组中可以存储多个不同类型的元素
- 数组是专门用来存储数据的对象
- 数组和对象的功能类似，都是用来存储数据的
不同的是对象中的属性操作是通过以字符串命名的属性名来进行操作的
而数组中是通过索引来操作元素的。
- 数组存储数据的性能更好，所以我们在开发中都是使用数组来保存数据的

##### 创建数组对象   
> 使用typeof检查一个数组时，会返回object

    - var arr = new Array();
            - var arr = [  ];（数组的字面量）
    
##### 向数组中添加元素
* 语法：
    数组[索引] = 元素
  - 索引index，是从0开始的整数
* 创建一个数组，数组中只有一个元素10

        arr = [10];
* 创建一个长度为10的数组

        arr2 = new Array(10);
* 在创建数组时，直接向数组中添加元素
        
        var arr = [元素1,元素2,...元素N];
* 在数组中可以保存任意类型的元素,数组中的元素也可是以一个数组
  如果数组中放的还是数组，则我们称这种数组为二维数组`[[ ],[ ],[ ]]`
        
        arr = [
            1,
            true,
            "hello",
            {name:"孙悟空"},
            function(){alert("hello");},
            [1,2,3,4],
            ["hello",true]
                  ];
                  
##### 读取数组中的元素
* 语法：
  数组[索引]
* 如果读取数组中没有的元素，它不会报错而是返回undefined

##### 数组的属性和方法
1. length  
     - 获取数组中的长度（数组中元素数量）
     - 对于连续数组，length获取的就是数组中的元素的个数
     - 对于非连续数组，length获取到的是数组的最大索引+1（不要使用非连续数组）
                    length属性也可以修改
     - 如果长度大于原长度，则多出位置会空出来
     - 如果长度小于原长度，则一部分多余的元素会被删除
     - 向数组的最后添加一个元素,数组的最后的索引就是：最大索引+1
     - 语法：数组[数组.length] = 元素;
2. push()
    - 向数组的末尾添加一个或多个元素，并返回新的长度
3. pop()
    - 删除数组的最后一个元素，并返回被删除的元素
4. unshift()
    - 向数组的开头添加一个或多个元素，并返回新的长度
5. shift()
    - 删除数组的第一个元素，并返回被删除的元素
6. concat()
    - 连接两个或多个数组并将结果返回
           var result = arr.concat(arr2 , ["abc","bcd","efg"] , "hello" , "abc");
7. join()
    - 将数组中的所有元素连接为一个字符串,该方法不会对原数组产生影响，而是将结果做为返回值返回
     需要一个字符串作为参数，该字符串将会作为连接符，来连接数组中的元素
     如果不指定，则默认使用,逗号
8. reverse()
    - 反转数组，将数组中的元素的顺序颠倒
    - 该方法会影响原数组
9. sort()
    - 对数组中的元素进行重新排序，会影响到原数组，
           直接对原数组进行排序默认它是按照元素的Unicode编码进行排序的（升序）
    - 也可以通过一个回调函数来自定义排序的规则：
         - 需要在sort(  )传递一个回调函数作为参数，在函数中需要指定两个形参
         回调函数会被调用多次，每次都会将数组中的两个元素作为实参传递，
         但是具体是谁不一定，但是可以确定的是a一定在b的前边
         - 它会根据回调函数的返回值，来决定是否交换a和b的位置
              - 如果返回值 大于0，则两个元素交换位置
              - 如果返回值 等于0 则证明两个元素相等，位置不动
              - 如果返回值 小于0 则两个元素也不交换位置
              
                    数组.sort(function(a , b){								//升序排列，值小于等于0 位置不变
                        //return a - b;	
                        //降序，值大于0掉换位置
                        return b - a;
                    });
10. slice()
    - 可以从数组中截取出指定的元素
    - 该方法不会影响原数组，而是将截取的结果封装为一个新的数组返回
    - 参数：
        1. 第一个参数,截取开始位置的索引（包括开始位置）
        2. 第二个参数,截取结束位置的索引（不包括结束位置）
    - 第二个参数可以省略，如果省略则会一直截取到最后一个元素
    - 参数也可以是一个负值，如果是负值,则会从后向前计算	
11. splice()	
    - 可以删除数组中的指定元素，并向数组中添加新的元素,该方法会影响到原数组
    - 返回值：被删除的元素
    - 参数：
        1. 删除开始位置的索引（包括开始位置）
        2. 删除的数量
        3. 三个以后，可以指定一些新的元素，这些元素将会插入到开始位置元素的前边
    - 例子：
    
            删除元素
            arr.splice(0 , 2); //从0开始删除2个元素
            arr.splice(0, 2 , "a" , "b") //从0开始删除2个元素,并使用两个新的元素来替换
            arr.splice(0, 0 , "a" , "b") //向开始位置插入两个元素

##### 遍历数组
* 遍历数组指的就是将数组中的所有的元素全部获取到
* 一般情况下，都是通过for循环来对数组进行遍历

    for(var i=0 ; i<数组.length ; i++){
        数组[ i ];
        }
        
#### <div id='h'>八.包装类</div>
通过包装类，可以将一个基本数据类型包装为一个对象
* String() 将一个字符串包装为一个String对象
* Number() 将一个数值包装为一个Number对象
* Boolean() 将一个布尔值包装为一个Boolean对象

> 这三个包装类，我们在开发中不要使用,因为一旦创建的是对象，再做比较时，就不是比较值而是比较地址

    当我们调用基本数据类型的属性或方法时，它会将其临时转换为对象，
    然后去调用对象的属性和方法，调用完毕将其销毁。
    所以我们不需要创建基本数据类型的对象，也可以对基本数据类型调用方法

##### String
字符串在底层实际上是以字符数组的形式保存的，所以字符串的方法都和数组的类似
* 属性：length 获取字符串的长度
* 方法:
1. charAt()  - 根据索引获取字符串指定位置的字符
2. charCodeAt()   - 根据索引获取字符串指定位置的字符的Unicode编码
3. String.fromCharCode()  - 根据字符编码返回对应的字符
4. indexOf()
5. lastIndexOf()
     - 可以检索指定内容在字符串中的位置
     - 参数：1.要检索的内容    2.检索的起始位置
     - indexOf从前往后找 ， lastIndexOf从后往前找
     - 如果找到了，则返回其第一次出现的索引，如果没有找到，则返回-1
6. slice()  - 截取字符串
      - 参数：
          1. 截取开始位置的索引（包括）
          2. 截取结束位置的索引（不包括）
    - 第二个参数可以省略不写，如果不写则一直截取到最后
    - 索引可以是一个负数，如果是负数则从后向前计算	
7. substring()  
    - 截取字符串
    - 参数：
        1. 截取开始位置的索引（包括）
        2. 截取结束位置的索引（不包括）
     - 第二个参数可以省略不写，如果不写则一直截取到最后
     - 它不能接收负数作为参数，而且他会自动调整参数的位置，
        如果第一个参数 大于 第二个，则自动交换位置
8. substr()	
    - 截取字符串
    - 参数：
        1. 截取开始位置的索引（包括）
        2. 截取的个数
9. concat()  
    - 可以用来连接两个或多个字符串，作用相当于+
10. toLowerCase() 
    - 把字符串转换为小写。
    
11. toUpperCase() 
    - 把字符串转换为大写。 
    
               result = str.toUpperCase();
12. split()   
    - 将一个字符串拆分为一个字符串数组
    - 参数：一个字符串，根据该字符串来拆分数组
    
              str = "a@b@c@d@e";
              result = str.split("");
    - 也可以传递一个正则表达式作为参数，这样将会根据正则表达式来拆分字符串
13. search() 
    - 根据正则表达式从一个字符串中搜索指定的内容,他可以接收一个正则表达式作为参数
    - 参数：正则表达式
    - 如果找到了，则返回该内容第一次出现的索引，如果没有找到则返回-1
14. match()  
    - 根据正则表达式将字符串中符合条件的内容提取出来，并封装到一个数组中返回
15. replace()   
    - 使用新的内容来替换指定的内容
    - 参数： 
        1. 被替换的内容（可以是一个正则表达式）
        2. 新的内容
        
#### <div id='i'>九.运算符（操作符）</div>
通过运算符可以对一个或多个各种类型的值进行运算
##### typeof
* typeof可以用来检查一个变量的类型，并将检查结果的字符串返回

##### 算数运算符
*  `+`加法   `-` 减法    `*` 乘法     `/` 除法     `%` 取模（取余数）
* 这些算数运算符和数学中的规则是一致
* 注意:
    1. 当为两个字符串做加法运算时，它会将两个字符串拼成一个
    2. 当其他的数据类型和字符串做加法运算时，它会先将其他的数据类型转换为字符串，然后再做拼串的操作
    3. 除了和字符串做加法，其他的非Number数据类型，在做算数运算时，都会先转换为Number然后再运算
    利用该特点可以通过为任意变量 加上一个空串的形式来将其转换为String
    4. 任何值和NaN做运算都会返回NaN（除了和字符串做加法）

##### 一元运算符
* 指只有一个操作数的运算符
* 一元+：就相当于数学中的正号，它不会对一个数值产生任何影响
* 一元- ：将相当于数学中的负号，它会对一个数值在符号位取反
* 注意：
    * 如果对非Number类型的值做一元的+ - 运算，会先将其转换为Number然后再运算.可以通过一元的+来将任意的数据类型转换为Number，它的原理和Number()函数，但是使用起来更加简单.

##### 自增
- 自增可以数值立即自增1（为变量在原值基础上加1）
- 自增使用++作为运算符
- 自增分成两种前++（++a） 和 后++（a++）
- 无论是++a 还是 a++都会立即使原变量自增1  
     - 不同的是++a 和 a++的值不同  
     - ++a的值是变量自增后的值（新值）  
     - a++的值是变量自增前的值（原值） 

##### 自减
- 自减可以数值立即自减1（为变量在原值基础上加1）
- 自减使用--作为运算符
- 自减分成两种前--（--a） 和 后--（a--）
- 无论是--a 还是 a--都会立即使原变量自减1  
    - 不同的是--a 和 a--的值不同  
    - --a的值是变量自减后的值（新值）  
    - a--的值是变量自减前的值（原值）  

##### 逻辑运算符
* 或||
    - ||可以对符号两侧的值做逻辑或运算
    - 只要符号两侧有一个true，就会返回true，只有符号两侧都是false时，才会返回false
    - 或也是短路的或，如果第一个值是true，则不看第二个值
    - 对于非布尔值，它会将其转换为布尔值，然后再运算，最终返回原值
    - 规则：
        - 如果第一个值是true，则返回第一个值
        - 如果第一个值是false，则返回第二个值
* 与&&
    - &&可以符号两侧的值做逻辑与运算
    - 只有符号两侧的值都为true时，才会返回true，否则只要有一个false它就会返回false。
    - 与是短路的与，如果第一个值是false，则不看第二个值了
    - 对于非布尔值，它会将其转换为布尔值，然后再运算，最终返回原值
    - 规则：
        - 如果第一个值是false，则返回第一个值  
        - 如果第一个值是true，则返回第二个值
* 非!
    - !可以对一个值做逻辑非的运算
    - 他可以对一个布尔值进行取反操作，true变false false变true
    - 对于非布尔值，它会先将其转换为布尔值，然后再取反
    - 所以我们可以利用该特点，通过为一个值做两次非运算来将其转换为布尔值，它的原理和Boolean()函数一样
* 赋值运算符
    - 通过赋值运算符可以将一个值赋值给一个变量
        
            =      - 可以将符号右侧的值赋值给符号左侧的变量
            +=    - a += 5 等价于 a = a + 5
            -=     - a -= 5 等价于 a = a - 5
            *=     - a *= 5 等价于 a = a * 5
            /=     - a /= 5 等价于 a = a / 5
            %=   - a %= 5 等价于 a = a % 
        
##### 关系运算符
- 使用关系运算符可以比较两个值之间的大小等于的关系

      > 大于     >= 大于等于     < 小于      <= 小于等于
- 关系运算符的规则和数学中的规则是一样的，
  使用时，如果两个值的关系成立则返回true，关系不成立则返回false
- 对于非Number类型的值做关系运算时，它会将其转换为Number，然后再运算
- 如果比较两个字符串的关系，它是比较字符串的Unicode编码，注意比较字符串时，是将字符串中的字符的Unicode编码逐位进行比较  
    - 利用该特点可以对英文进行比较，并且将英文按照字母顺序进行排序
    - 比较两个中文的大小的意义不是特别，在比较两个纯字符串的数字时，有可能会得到一个错误的结果

##### 相等运算符
1. == 相等运算
    * 可以用来检查符号两侧的值是否相等，如果两个值的类型不同，会先将其转换为相同的类型然后再比较
      如果比较后两个值相等则返回true，否则返回false。（一般情况下都会转换为Number然后比较，但是不绝对）
    * 由于undefined衍生自null，所以比较这两个值是否相等时会返回true
    
            //console.log(null == undefined); //true
    * NaN不和任何值相等，包括它自身,不能通过相等运算符来判断一个值是否是NaN
            
            //console.log(NaN == NaN); //false
            
    * isNaN()函数
      - 我们可以同isNaN()这个函数来判断一个变量是否是NaN
      - 如果变量时NaN，则返回true，否则返回false
      
              var a = NaN;
              console.log(isNaN(a)); //true
2. === 全等运算
    * 检查符号两侧的值是否全等，和相等类似，不同的是全等不会做自动的类型转换，如果两个值的类型不同直接返回false
3. != 不等运算
    * 检查符号两侧的值是否不等，如果不等则返回true，如果相等则返回false
      不等也会做自动的类型转换，如果转换后的值相等，也会返回false
4. !== 不全等运算
    * 和不等类似，但是不会做自动的类型转换，如果两个值的类型不同，直接返回true

##### 三元运算符?:
* 语法：条件表达式?语句1:语句2;
* 三元运算符在执行时，会先对条件表达式进行求值判断  
    * 如果判断结果为true，则执行语句1，并将其的执行结果返回  
    * 如果判断结果为false，则执行语句2，并将其执行的结果返回

#### <div id='j'>十.流程控制语句</div>
程序默认都是自上至下一行一行的执行的，
通过流程控制语句可以改变程序的执行顺序，
或者让某些语句反复的执行多次。

##### 流程控制语句的分类：
1. 条件判断语句
2. 条件分支语句
3. 循环语句

##### 条件判断语句（if语句）
* 语法一：

            if(条件表达式){
                语句...
            }
- 执行流程：
    * if语句，在执行时会先对if后的条件表达式进行求值判断，
    * 如果判断结果为true，则执行if后的语句，否则不执行
    * 如果条件表达式的求值结果是一个非布尔值，则会将其转换为布尔值，然后再判断
    
* 语法二：

                if(条件表达式){
                    语句...
                }else{
                    语句...
                }
- 执行流程：
    * if...else语句，在执行时，会先对if后的条件表达式进行求值判断，
    * 如果判断结果为true，则执行if后的语句
    * 如果判断结果为false，则执行else后的语句
* 语法三：
                
            if(条件表达式){
                    语句...
                }else if(条件表达式){
                    语句...
                }else if(条件表达式){
                    语句...
                }else{
                    语句...
                }	
- 执行流程：
    * if...else if...else语句，在执行时，会依次对条件表达式进行求值判断，
   （如果返回结果为undefined，则转换为false）
    * 如果判断结果为true，则执行当前if后的语句，执行完毕退出语句
    * 如果判断结果为false，则继续向下判断，直到找到结果为true的为止
    * 如果所有的条件表达式都为false，则执行else中的语句。
    * if...else if...else 多组语句中只会执行一组，一旦有满足条件的，就会再去检查别的条件，所以在使用该语句时，一定要注意条件的顺序

##### 条件分支语句switch...case
* 语法：

        switch(条件表达式){
            case 表达式:
                语句...
                break;
            case 表达式:
                语句...
                break;
            default :
                语句...
                break；	
        }
* 执行流程：
     * switch...case在执行时，会自上向下依次将case后的表达式和switch后的条件表达式进行全等比较
     * 如果比较结果为true，则从当前case处开始向下执行代码
     * 如果比较结果为false，则继续向下比较，直到找到true为止
     * 如果一直找不到为true的结果，则执行default后的代码
     * 可以通过break语句来立即退出switch语句，一般情况情况下，每一个case的最后，或default的最后都要添加break

##### 循环语句
* while
    
        while(条件表达式){
                        语句...
                    }
    * 执行流程  
        1. while语句在执行时，会先对while后的条件表达式进行求值判断
        2. 如果结果为false，则终止循环
        3. 如果结果为true，则执行一次循环体
        4. 循环体执行完毕，继续对条件表达式进行求值判断，依次类推
* do...while
        
        do{
                      语句...
                 }while(条件表达式)
     * 执行流程
        1. do...while语句在执行时，会立即执行循环体一次，
        2. 循环体执行完毕，然后对while后的条件表达式进行求值判断
        3. 如果结果为false，则终止循环
        4. 如果结果为true，则继续执行循环体，依次类推
        
    > while语句是先判断再执行，do...while是先执行再判断
      do...while可以确保循环体至少执行一次

* for
    > for循环页面一加载就会立即执行
    
        for(①初始化表达式;②条件表达式;④更新表达式){
                        ③语句...
                    }
    * 执行流程
        1. 执行①初始化表达式初始化一个变量
        2. 对②条件表达式进行求值判断
            * 如果结果为false，则终止循环
            * 如果结果为true，则执行循环体③
        3. 循环体执行完毕，执行④更新表达式，对初始化变量进行更新
        4. 更新完成以后重复2	
        （初始化表达式只会执行一次）
    * 死循环  
        1. for循环中的三个表达式，可以省略不写，也可以写在循环的外部
        2. 如果将三个表达式都省略了，则for循环就会变成一个死循环会一直执行
              
                  for(;;){
                    document.write(i + "<br />");
                    alert("hello");
                        }
    * 可以为语句添加一个label，这个label就相当于语句的一个名字
            
            hello:
            for(var i=0 ; i<5 ; i++){
                for(var j=0 ; j<5 ; j++){
                    if(j == 2){
                        //终止label为hello的循环
                        break hello;
                    }
                    console.log("内存循环:"+j);
                }
                console.log("------>外层循环:"+i);
            }
            
##### break和continue
* break
* break关键字，可以用来退出循环和switch语句
* 当执行到break时，循环和switch会立即结束
* break只会对离他最近的那个循环起作用
（break不能用于if语句）
* continue
* continue可以用来跳过当次循环，
* 当执行到continue时，当次循环立即结束，直接跳到下一次循环
* 同样 continue也是对离他最近的循环其作用

#### <div id='k'>十一.正则表达式</div>
正则表达式可以用来定义一些字符串的格式规则
计算机可以根据这些规则来检查一个字符串是否符合规则
或者将字符串中符合规则的内容提取出来。
正则表达式可以同时设置多个匹配模式，并且没有顺序要求
1. 创建正则表达式的对象

    var reg = new RegExp("正则表达式","匹配模式");
    使用字面量来创建一个正则表达式
    var reg = /正则表达式/匹配模式;
    正则表达式中严格区分大小写
2. 方法
* test()  :可以用来检查一个字符串是否符合正则表达式的规范，如果符合返回true，否则返回false
3. 匹配模式
* i 忽略大小写匹配
* g 全局匹配
4. 基本语法
    
    | 或
    [  ] 或
    [^ ] 除了
    ^	以。。。开头
    $ 	以。。。结尾
    [a-z] 任意小写字母
    [A-Z] 任意大小字母
    [A-z] 任意字母
    [0-9] 任意数字
    {n} 正好n次
    {m,n} m-n次
    {m,} m次以上
    + 至少1次 {1,}
    ? 0-1次 {0,1}
    * 任意次 {0,}
    . 任意字符
    \ 转义字符
    \. ———>  .
    \\ ———>  \
    \w [A-z0-9_]任何字类字符
    \W [^A-z0-9_]
    \d [0-9]
    \D [^0-9]
    \s 空格
    \S 除了空格
    \b 单词边界
    \B 除了单词边界
5. 量词 - 可以通过量词，来表示一个字符出现的次数
6. 编写一个正则表达式，检查一个字符串是否是合法的手机号

      var phoneReg = /^1[3-9][0-9]{9}$/;
      var phoneNumber = "17017891231";
      console.log(phoneReg.test(phoneNumber));
7. 使用构造函数创建一个正则表达式时，正则表达式是以字符串的形式传递的
  但是 \ 也是字符串中的转义字符,注意正则的构造函数中，需要使用 \\\ 来表示一个 \
       
8. 接收用户输入的字符串，然后以相反的顺序输出

                var str = prompt("请输入一个字符串:");
       
                //将str转换为数组
                var arr = str.split("");
                
                //反转数组
                arr.reverse();
                
                str = arr.join("");
                
                console.log(str);
9. 创建一个程序来去除字符串中的前后空格

            //去除空格，就是将字符串中的空格替换为空串
            var reg = / \s/g;
            
            //匹配开头的空格
            reg = /^\s+/;
            
            //匹配结尾的空格
            reg = / \s+$/;
            
            //匹配开始和结尾的空格
            reg = /^\s+|\s+$/g;
            
            username = username.replace(reg,"");   
10. 电子邮件地址的正则表达式

            var emailReg = /^\w+(\.\w+)*@[a-z0-9-]+(\.[a-z]{2,5}){1,2}$/;
            
            var email = "hello.abc@abc.com.cn";
            
            console.log(emailReg.test(email)); 			    			

#### <div id='l'>十二.作用域</div>
作用域简单来讲就是一段代码的作用范围，
在JS中作用域分成两种：
全局作用域、函数作用域
##### 全局作用域
* 所有直接写在script标签中的代码都在全局作用域中
- 全局作用域在页面（打开）加载时创建，在页面关闭时销毁
- 在全局作用域中创建的变量是全局变量，在页面中的任意位置都可以访问
- 全局作用域有一个全局对象window，它代表的是浏览器的窗口
- 在全局作用域中创建的变量都会作为window对象的属性保存，
- 在全局作用域中创建的函数都会作为window对象的方法保存
- 在全局作用域中创建的变量和函数可以在整个页面中使用，
- 在全局作用域中创建的变量称为全局变量

##### 函数作用域
- 每调用一次函数就会创建一个新的函数作用域，
- 函数作用域在函数调用时创建，在函数调用结束时销毁
- 在函数作用域中可以访问全局变量，在全局作用域中无法访问函数作用域中的变量
- 在函数作用域，如果不使用var关键字来声明变量，则该变量将会变成全局变量（避免这样使用）
- 当在函数作用域中使用一个变量时，它会先在自身中寻找，如果找到了则直接使用，如果没有找到，则继续向上一级作用域中寻找，如果找到了则使用，没找到则继续,直到找到全局作用域了，如果依然没有，则会报错
- 如果需要在函数中访问全局变量，可以通过window来访问

##### 声明提前
* 变量的声明提前
    * 在全局作用域中或函数作用域中，如果使用var关键字声明了变量，
      则变量的声明操作将会在所有的代码执行前进行，但是不会赋值
      如果声明变量时不写var，就相当于直接向window中添加属性
      
               a = 10;    console.log(a);
* 函数的声明提前
    * 在全局作用域中或函数作用域中，如果使用函数声明的形式创建函数，
      则函数会在所有的代码执行前被创建，所以我们可以在函数声明前就对其进行调用
      但是函数表达式没有该特性

#### <div id='m'>十三.样式的操作</div>
##### 操作内联样式
* 读取内联样式（通过style属性只能读取元素的内联样式，不能读取到样式表中的样式）

            - 语法：元素.style.样式名
* 修改内联样式
  
            - 语法: 元素.style.样式名 = "样式值"
  注意：样式名就是CSS中的样式名，但是如果样式名带有-，
           则需要将样式名修改为驼峰命名法，
        将-去掉，-后的字母改大写。
        
        例子：background-color --> 	backgroundColor
> 使用style设置样式都是元素的内联样式，
  而内联样式的优先级又是最高的，所以我们通过js修改的样式，往往会立即生效
  如果样式添加了!important 则它会获取到最高的优先级甚至超过内联样式
  此时如果使用js来修改这个样式，则不能生效，所以尽量不要使用!important

##### 读取元素当前的样式
* IE8及以下	
    * 元素.currentStyle.样式名
    * currentStyle可以用来读取当前生效的样式，无论是样式表中
      还是内联样式，只要是生效的样式都可以获取到
      currentStyle中的样式都是只读的，不能修改
      该属性只支持IE浏览器，其他的浏览器都不支持
    
            - 例子：box1.currentStyle.backgroundColor
* 其他浏览器可以通过一个方法来获取元素的当前样式（不支持IE8及以下的浏览器） 	
    - getComputedStyle() 
    *  参数：  		
        1. 要获取样式的对象 		
        2. 伪元素（没有可以传null） 	
    - 这个方法会返回一个对象，在对象中封装了元素当前生效的样式
    
            getComputedStyle(元素,null)
            - 例子：getComputedStyle(box1 , null).backgroundColor
* 自定义一个函数来处理兼容问题
    * 这两个都不能兼容所有的浏览器，所以我们可以自定义一个函数来处理兼容问题
    * 参数：  
        1. 要获取样式的对象   
        2. 要获取的样式名
            
                function getStyle(obj  , name){ 	//如果该函数存在，则会返回true 	
                    if(window.getComputedStyle){ 	//如果是正常的浏览器,需要使用getComputedStyle 		
                        return getComputedStyle(obj , null)[name]; 	
                    }else{ 		
                        //如果进入else则证明浏览器不支持getComputedStyle() 		
                        //IE8需要使用currentStyle 		
                        return obj.currentStyle[name]; 	} 
                    }
                getStyle(box1 , "backgroundColor");
            

##### 其他样式相关的属性,其他获取样式的方式
* clientHeight
* clientWidth
    - 获取元素的可见高度和宽度   - 包括元素的内容区和内边距
         这些属性都是计算得来的，都是只读的
* offsetHeight
* offsetWidth
    - 获取元素的可见框的高度和宽度   - 包括元素的内容区、内边距和边框   
* offsetParent
    - 获取当前元素的定位父元素
    - 会返回离当前元素最近的开启了定位的祖先元素，如果都没有开启则返回body
* offsetTop
* offsetLeft
    - 相对于其定位父元素（offsetParent）的水平，垂直偏移量   
* scrollHeight
* scrollWidth
    - 获取元素的整体高度和宽度   
* scrollTop
* scrollLeft
    - 垂直，水平滚动条滚动的距离
    - 判断滚动条是否滚动到底：
    
            1. 垂直滚动条   scrollHeight - scrollTop = clientHeight
            2. 水平滚动条   scrollWidth - scrollLeft = clientWidth

#### <div id='n'>十四.事件(event)</div>
事件就是用户和浏览器之间的交互行为。

    比如：点击鼠标 移动鼠标 打开窗口 页面加载 关闭窗口等
在JS中可以通过对事件进行响应来完成和用户的交互,可以在标签的指定属性中来设置一些JS代码，这样当指定的事件被触发以后，这些代码将会被执行.
##### 绑定事件的响应函数    
* 如果需要为一个元素绑定事件的响应函数，只需要为该元素的指定的事件属性赋值一个函数即可
  这样当元素的事件被触发时，其所对应的函数将会被执行
  这个函数是一个回调函数，我们也称它为事件的响应函数
* 在元素的标签内部的指定的事件属性中，设置JS代码

         <button onclick="....">我是一个按钮</button>
* 通过为元素的指定事件属性设置响应函数来处理事件

          <button id="btn">点我一下</button>
          <script>
            var btn = document.getElementById("btn");
            btn.onclick = function(){
                        ....
                };
          </script>
* 当我们点击一个超链接以后，它会默认跳转到其他的页面
  这个是超链接的默认行为，如果不希望发生默认行为可以在响应函数的最后 return false 来取消默认行为

##### 事件对象
* 事件的响应函数在被调用时，每次都会有一个实参被传递进函数
* 这个实参就是事件对象，在事件对象中封装了当前事件的相关信息。比如：鼠标的坐标、键盘的按键、鼠标的按键。。。。我们可以通过事件对象来获取到这些信息
* 我们可以在事件的响应函数中定义一个形参对事件对象进行引用
* 但是在IE8中并没有将事件对象作为实参传递，而是作为 window 对象的属性保存

          btn.onclick = function(event){
                event = event || window.event;
            };	
* 在IE8中需要使用window.event 在其他浏览器需要使用event
  
          if(!event){ 	//如果event不存在 	
                event = window.event; }
          或者
          兼容IE8的事件对象
           event = event || window.event;
* 获取鼠标的坐标  
    
        //clientX 鼠标的水平坐标    clientY 鼠标的垂直坐标
        var x = event.clientX; var y = event.clientY;

##### 事件的冒泡

* 事件的冒泡指的是事件的向上传导，当元素上的事件被触发时，
  其祖先元素上的相同事件也会被触发。
* 冒泡在开发中大部分情况都是有利的，但是有些情况我们不希望出现冒泡，
  可以通过事件对象来取消冒泡。
  将事件对象的 cancelBubble 设置为 true，即可取消冒泡。

##### 事件的绑定
* addEventListener()
    - 通过该方法也可以为一个元素绑定响应函数，
    而且它可以同时为一个元素的同一个事件绑定多个响应函数
    - 参数：
      1. 事件类型的字符串（不要on）
      2. 事件的回调函数
      3. 是否在捕获阶段触发事件（false）
    - 例子：       
                
            box1.addEventListener("click" , function(){} , false);
            - 不支持IE8及以下的浏览器

* attachEvent()
    * 作用和上述方法一致，兼容IE浏览器
      - 参数：	
        1. 事件类型的字符串（要on）
        2. 事件的回调函数
      - 例子：
      
             box1.attachEvent("onclick" , function(){});
             
* onscroll －这个事件会在元素的滚动条滚动时被触发
* onmousemove －鼠标移动事件，当鼠标在元素中移动时该事件会被触发

#### <div id='o'>十五.DOM</div>
* Document Object Model
- 文档对象模型
    
    文档 - 文档代表的是整个HTML页面
    对象 - DOM将网页中的所有的节点都转换为了对象
        - 转换为对象以后，我们就可以以纯面向对象的形式去操作网页
    模型 - 模型用来表示对象与对象之间的关系
- 通过DOM可以对网页做各种操作
* 在浏览器中已经为我们提供了一个对象 document  
* document代表的是整个的网页，它是网页中所有节点的祖先  
* document是window对象的属性，可以在网页中直接使用  
* console.log(document);

##### 节点（Node）
> 节点是组成网页的最基本的单位，网页中的每一个部分都可以称为是一个节点
  但是虽然都是节点，但是他们的类型也各不相同
  
##### 常用的节点
* 文档节点 document  - 代表的是整个网页
    * document的方法
        1. document.documentElement
             - 获取页面的根元素（html元素）
        2. document.body
             - 获取body元素
             - document.getElementsByTagName("body")[0]
        3. document.all
              - 获取页面中的所有元素
              - document.getElementsByTagName("*")
        4. document.getElementsByClassName("class值")
              - 根据元素的class属性查询一组元素节点对象
              - 不兼容IE8及以下的浏览器
        5. document.querySelector()	
              - 根据CSS选择器查询页面中的一个对象
        6. document.querySelectorAll()	
              - 根据CSS选择器查询页面中的一组对象
              - 这两个方法使用方式一样，都是需要一个选择器的字符串作为参数，将会根据该选择器去页面中查询元素。        
         > querySelector()只会找到第一个符合条件的元素，它的返回值是一个对象                 
         querySelectorAll() 会找到所有符合条件的元素，它的返回值是一个数组，
                         即使只有一个符和条件它也会返回一个数组        
* 元素节点 element  - 代表网页中的标签
* 文本节点 text  - 网页中的文本内容
* 属性节点 attribute  - 标签中的属性

##### DOM的查询方法
* 通过document调用
    - 根据元素的id属性值查找一个元素节点对象
            
            document.getElementById("id属性值");
    - 根据标签名查找一组元素节点对象
            
            document.getElementsByTagName("标签名");
    - 根据元素的name属性值查找一组元素节点对象
            
            document.getElementsByName("name属性值");
            
* 通过具体的元素节点调用
    - 根据标签名查找当前元素的后代元素
    
              元素.getElementsByTagName("")；
    - 获取当前元素的所有的子节点    	
            
             元素.childNodes
    - 获取当前元素的所有子元素    	
            
             元素.children
    - 获取当前元素的第一个子节点    	
            
             元素.firstChild
    - 获取当前元素的最后一个子节点   	
            
             元素.lastChild
    - 获取当前元素的父元素   	
            
             元素.parentNode
    - 获取前一个兄弟节点，会获取到空白的文本节点   	
            
             元素.previousSibling
    - 获取后一个兄弟节点，会获取到空白的文本节点    	
            
             元素.nextSibling
    > 根据w3c的规范，在元素中空白的文本节点，也被认为是父元素的子节点
      在IE8中不会将空白节点当成子节点
      
##### 读取元素中的属性
- 语法：元素.属性名
- 例子：

        ele.value
        ele.name
        ele.id
        ele.className 
        
##### 修改元素的属性
- 语法: 元素.属性名 = 属性值
- 例子：

        ele.value = ""
        ele.name = ""
        ele.id = ""
        ele.className = ""	
        
##### innerHTML 和 innerText
- innerHTML 可以读取或设置元素内部的HTML代码
- innerText 可以读取或设置元素内部的文本内容  
  innerText 获取自动去除HTML标签，只返回文本
- 读取元素内部的文本内容：

        元素.innerHTML
        元素.innerText
        元素.firstChild.nodeValue

##### DOM的修改
- 创建一个元素节点对象，并将新创建的对象返回

        document.createElement("标签名")
- 创建一个文本节点对象，并将其返回

        document.createTextNode("文本内容")
- 给父节点添加子节点

        父节点.appendChild(子节点)
- 将新的子节点插入到指定子节点的前边

        父节点.insertBefore(新节点,旧节点)
- 使用新节点替换已有节点

        父节点.replaceChild(新节点,旧节点)
- 删除子节点

        父节点.removeChild(子节点)
        子节点.parentNode.removeChild(子节点)

#### <div id='p'>十六.BOM</div>
浏览器对象模型  
在BOM中为我们提供了一组对象，让我们可以完成对浏览器的操作

##### BOM对象
> 这些BOM对象都是window的对象的属性，可以在页面中直接使用

- Window
    - 代表的是浏览器的窗口
- Navigator
    - 代表的是浏览器的信息
- Location
    - 代表浏览器的地址栏信息
- History
    - 代表浏览器的历史记录
- Screen
    - 代表用户的屏幕的信息
    
##### Navigator
* 代表的是浏览器的信息，浏览器的版本 品牌 用户的系统信息
    通过该对象我们可以识别用户使用的浏览器
* 由于历史原因Navigator对象中的大部属性都已经不能用来判断浏览器的信息了
    - 在Navigator中还有一个属性 userAgent 可以用来判断浏览器的信息
    - userAgent实际上就是一个用来描述浏览器信息的字符串
* 不同的浏览器会具有不同的userAgent，我们可以通过它来识别不同的浏览器
    - 火狐：
              
              Mozilla/5.0 (Windows NT 6.1; WOW64; rv:51.0) Gecko/20100101 Firefox/51.0
    - chrome
    
              Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36
    - IE8
    
              Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)
    - IE9
    
              Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)
    - IE10
    
              Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; WOW64; Trident/7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)
    - IE11
    
              Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; rv:11.0) like Gecko
        - 在IE11中已经完全去除了和微软 IE相关的一切标识，也就是说通过UserAgent已经无法识别出浏览器是否是IE11
        - 这里我们就需要通过一些特殊的手段来识别IE11
          > 判断当前浏览器的版本
            
                    if(/firefox/i.test(ua)){
                        alert("你是火狐浏览器~~~");
                    }else if(/chrome/i.test(ua)){
                        alert("你是谷歌浏览器~~~");
                    }else if(/msie/i.test(ua)){
                        alert("你是IE浏览器~~~");
                    }else if("ActiveXObject" in window){
                        alert("你是IE11~~~");
                    }
        - 我们也可以通过一些IE中独有的对象来识别IE浏览器
          * 	ActiveXObject

                      //alert("ActiveXObject" in window);

##### History
* 可以用来操作浏览器的历史记录,由于隐私的原因，该对象不能获取到具体的历史记录,而只能控制浏览器向前或向后翻页
- History只能访问当次的浏览记录
- 属性
    * history.length - 当次访问的历史记录的数量
- 方法
    - 可以用来返回到前一个页面，相当于浏览器的回退按钮
        
            history.back()
    - 可以用来跳转到下一个页面，相当于浏览器的前进按钮

            history.forward()
    - 可以用来跳转到指定的页面
        > 它需要一个整数作为参数，将会跳转指定数量的页面
        
                history.go()
      
##### Location
* 代表的浏览器的地址栏信息，通过它可以获取浏览器的地址栏信息，也可以修改地址栏信息
    - 如果直接打印location，则会输出浏览器的完整的地址
    - 如果直接修改location，则浏览器会自动跳转到修改后的页面
* 方法
    * assign()
        * 用来跳转到一个新的页面，作用和直接修改location一样
          > 这两种方式，都可以用来跳转页面，而且都会生成历史记录
    * replace()
        * 用来跳转到一个新的页面，但是不生成历史记录（不能使用回退按钮回退）
    * reload()
        * 刷新当前网页，作用和网页的刷新按钮相同
        - 方法中可以接收一个true作为参数，如果传了true，则会强制清空缓存来刷新页面

#### <div id='q'>其他补充</div>

##### Math
* 在JS中可以通过Math做数学运算相关的操作
  - Math不是构造函数，它就是一个普通的对象，所以使用Math不需要创建对象，直接使用即可
  - Math它里边封装了数学运算相关的属性和方法
  这种对象我们称为工具类
* 常量：Math.PI 圆周率    。。。
* 方法：
    * Math.abs() 获取一个数字的绝对值
    * Math.ceil() 对一个数字进行向上取整，小数点后有有效值就向上进一
    * Math.floor() 对一个数字进行向下取整
    * Math.round() 对一个数字进行四舍五入取整
    * Math.random() 获取一个0-1之间的随机数
         - 生成一个0-x之间的随机数
                
                Math.round(Math.random()*x);
         - 获取指x - y的随机数
                
                Math.round(Math.random()*(y-x) + x)
    * Math.sqrt() 对一个数进行开方运算
    * Math.pow(x , y) 返回x的y次幂
    * Math.max() 求多个数中的最大值
    * Math.min() 求多个数中的最小值
    
##### Date
* 在JS中使用Date来表示一个时间
* 创建Date对象
     - 创建一个表示当前时间的对象
            
            var d = new Date();
     - 创建一个指定时间的date对象
        需要将一个时间的字符串作为参数传递进构造函数
        日期的格式：月/日/年 时:分:秒
            
            var d = new Date("月/日/年 时:分:秒");
* 方法
    * getDate()  - 获取当前日期对象是几号
    * getDay()   - 获取当前日期是周几（0-6）
            - 0表示周日 1表示周一 。。。。
    * getMonth() - 从 Date 对象返回月份 (0 ~ 11)。 
            - 0表示1月 1表示二月 。。。
    * getFullYear() 
            - 从 Date 对象以四位数字返回年份。 
    * getHours() 
            - 返回 Date 对象的小时 (0 ~ 23)。 
    * getMinutes() 
            - 返回 Date 对象的分钟 (0 ~ 59)。 
    * getSeconds() 
            - 返回 Date 对象的秒数 (0 ~ 59)。 
    * getMilliseconds() 
            - 返回 Date 对象的毫秒(0 ~ 999)。 
    * getTime() 
        - 返回当前日期对象的时间戳
        - 时间戳，指从格林威治标准时间的1970年1月1日0时0分0秒到当前日期所经过的毫秒数
             >（计算机底层都是使用时间戳来保存一个时间的）
                     1秒 = 1000毫秒
    * Date.now()	
            - 可以用来获取当前的时间戳
                             //在循环执行前获取一个时间戳
                var begin = Date.now();
                
                /*for(var i=0 ; i<100 ; i++){
                    console.log(i);
                }*/
                //在循环执行后获取一个时间戳
                var end = Date.now();
                
                //console.log(end - begin);

##### 测试程序的运行的性能
* 在程序开始时，开启一个计时器
* console.time()可以用来开启一个计时器
* 它需要一个字符串作为参数，这个字符串将作为计时器的唯一标识console.time("test");
* console.timeEnd()可以用来停止一个计时器
* 它需要一个字符串作为参数，这个字符串必须是计时器的唯一标识
* console.timeEnd("test");
*  可以考虑对代码优化

##### debug
* 日常开发中可以同debug来对程序进行调试
- 通过debug可以使程序运行暂停，然后手动控制程序的运行

##### 文档的加载
* 浏览器在加载一个网页时，是从上至下一行一行加载的.所以如果我们将JS代码写在页面的上边，这样当加载到JS代码时会立即执行。在JS代码执行时，页面还没有加载完毕，将会导致我们无法正常获取到DOM对象。所以为了可以正常获取到DOM对象，JS代码最好写在body的下边
* 为了解决这个问题，我们有两种方式
  1. 将JS代码编写在body的下边
  2. 将JS代码编写到window.onload = function(){}中
    window的onload事件在页面加载完成之后才会执行，
    将代码编写到它的回调函数中，就可以确保代码执行时，
         页面已经加载完毕了
  这样既可以将代码写在上边，又可以在页面加载完毕之后在执行

##### 异常处理（try...catch...finally）
* 在JS中程序的运行一旦出现错误，则程序会立即终止.在JS中 可以使用 try...catch语句来对异常进行处理
* 语法：

        try{
            //我们可以将有可能出现异常的代码放到try中                          
            //这样当代码在执行时，如果没有异常，则正常执行                          
            //如果出现异常，则代码不会执行，也不会将异常抛出
        }catch(e){
            //如果try中的语句出现了异常，则try不会执行，而是执行catch                          
            //我们可以将异常处理的代码编写catch来对异常进行处理                          
            //console.log("出错了~~~~");                          
            //catch中的e就是出现的异常信息
        }finally{
            //finally中的代码总会执行，无论是否报错
        
        }




